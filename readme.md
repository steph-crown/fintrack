# fintrack [in progress 1%]

this is a cli tool that helps you track your incomes and expenses locally without fears of storing your data in any remote server. this means you can use the data to do anything you want to do.

<!-- the point of this iis to show them how easy it is to add records. this is a valid command -->

```bash
fintrack add -c "Income" -a 4000
```

## how does it do it

- it creates a file ~/.fintrack/tracker.json (when `fintrack init` is run)
- it stores every income/expense recorded by the user using other commands there
- whenever user requests to see their financial history, it pretty prints this data in the json file in the console
- it allows user to export/convert this data (json) to a csv (for use in other situations)
- in the future, it'll have a means to pipe this data to some llm models for interpretation of financial lifestyle

## installation

- install the cli package

```
...
```

- run `fintrack init` to get started and open your system to any other command

## commands

- `fintrack init --currency NGN` to initialize a new tracking source file with the json structure and the default categories (Income, Expenses), and subcategory (Miscellaneous). Currency defaults to NGN. list of accepted currencies NGN, USD (...). If file already exists, tell user that cant proceed already initialize, that they can do `fintrack clear` to clear it
- `fintrack add --category <category_name> --subcategory <subcategory_name> --amount <amount> --description <description> --date <date>` (subcategory, date and description optional. date defaults to now, subcategory defaults to "Miscellaneous". for description, can use escape identifiers like \n.) any of the flags and values can come before the other. this is also valid
  `fintrack add --description <description> --subcategory <subcategory_name> --amount <amount> --category <category_name>`
- `fintrack delete <record_ids>` delete record by id (Comma-Separated list of ids)
- `fintrack delete --by-cat <category_names>` delete all records tied to a category (eg all income/ expenses. will show a confirmation prompt and inform user of the fact this can't be undone)
- `fintrack delete --by-subcat <subcategory_names>` delete all records tied to a subcategory (eg all income/ expenses. will show a confirmation prompt and inform user of the fact this can't be undone)
- `fintrack update <record_id> --category <category_name> --subcategory <subcategory_name> --amount <amount> --description <description> --date <date>` (updates record, accepts all flags as the `fintrack add` command, but all flags, icluding category is optional, but at least one flag must be passed)
- `fintrack list` list all records
- `fintrack list --first <number>` list the first `<number>` records
- `fintrack list --last <number>` list the last `<number>` records
- `fintrack list --start <start_date> --end <end_date>` list the records between both dates. both start and end are optional. start defaults to -Infinity, end defaults to Now.
- `fintrack list --category <category_name>` list all records attached to a category
- `fintrack list --subcategory <subcategory_name>` list all records attached to a subcategory
- `fintrack category list` view category list (names)
- `fintrack subcategory list` view subcategory list (names, date created)
- `fintrack subcategory add <name>` add subcategory (unique name)
- `fintrack subcategory delete <name>` delete subcategory (if some entries is tied to subcateory, cant delete. advise user to delete entries, or to call `fintrack delete --by-subcat <subcategory_names>`)
- `fintrack subcategory update --old <old_subcategory_name> --new <new_subcaegory_name>` update subcategory name
- `fintrack clear` delete entire file. ask for confirmation
- `fintrack total` gives total income and total expenses and net total (income - expenses)
- `fintrack describe` gives an EDA of the data. for now, basic EDA (please suggest?)
- `fintrack help`

> the category name and subcategory names accepted by the cli is case insensitive, but stores them in capitalized form in the json. e.g, you can create/access a subcategory as "wages" or "wAges" or "Wages", and they'll all refer to the same subcategory created as "Wages" in the json.

> Names should be alphanumeric and beginning with a letter.

> There is a default subcategory "Miscellaneous" that when record is added without setting subcategory, it uses miscellaneous

> Can't delete categories, nor "Miscellaneous" subcategory

> Date entered into cli is of the form "DD-MM-YYYY"

> update and create commands always display the new value of record created/updated so user knows what was done.

> deletes should show the record that was just deleted (in strikethrough or red or both)

## cli features

- auto complete

## data shape

- id (autogenerated, auto inc?)
- category (income, expense)
- subcategory
- description
- amount
- date (defaults to current date)

## what to ask?

- can i protect this file ~/.fintrack/tracker.json so only my program can write to it?

```json
{
  // for id lookup
  // what's the best data structure to use here though? hashmap or list. i need something i can very quicky get the id when given name, and also very quickly get the name when given id. should i use two maps (forward and reverse map i.e K->V and V->K or is there a way in rust to get the key given the value in O(1) or is there a better data structure?)
  "categories": {
    "Income": 1,
    "Expenses": 2
  },
  "subcategories": {
    "Miscellaneous": 1,
    "Groceries": 2
  },
  "records": []
}
```

## Design

for the design, here are my thoughts

- use Clap to parse cli arguments and create CliArgs Struct. in main binary (main.rs), have run() fn that calls this parser, then calls validate, display error if necessary and break or call the processor.
- the processor calls the respective module based on the second `fintrack` argument. there'll be modules for `init`, `add`, `delete`, `list`, `category`, `subcategory`, `clear`, `total`. for functionalities used across mutliple categories, functions will be created in `lib.rs`
- these modules will all have a `process` function called from the main `process` function, with the flags.
- for `init`, `add`, `delete`, `list`, `clear`, `total`, it's pretty straightforward. it calls its private functions to do computations and stuff, and potentially lib functions. at the end, the process function returns a response with shape of a `ProcessResponse` struct. this helps uniformity so the main process function handles all response the same way. and in case of error, they all return `ProcessError` custom error. So the return type of all process functions is therefore `Result<ProcessResponse, ProcessError>`.
- the main process function will have arguments for stdout and stderr writers and write to them accordingly with the result.

```rust
// process function signature (in the modules)
fn process(cli_args: CliArgs) -> Result<ProcessResponse, ProcessError>

// process function signature (in main)
fn process(cli_args: CliArgs, out_writer: &mut impl std::io::Write, err_writer: &mut impl std::io::Write) -> Result<ProcessResponse, ProcessError>

// do you think these fields are enough? do you suggest other fields to be added?
struct ProcessResponse {
  success: bool,
  stdout: String // message displayed to stdout
}

struct ProcessError {
  stderr: String // message displayed to stderr
}
```

you can draw a design system diagram if necessary
